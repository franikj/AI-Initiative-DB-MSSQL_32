As a DB engineer I need to develop a stored procedure that calculates customer revenue based on the provided input parameters. The revenue represents the total sales revenue generated by a customer within a specific period. This stored procedure will provide a convenient way to obtain accurate revenue information for analysis and reporting purposes.

Database: WideWorldImportersDW-Standard
Tables need for calculations: SELECT  [Customer Key]
      ,[WWI Customer ID]
      ,[Customer]
      ,[Bill To Customer]
      ,[Category]
      ,[Buying Group]
      ,[Primary Contact]
      ,[Postal Code]
      ,[Valid From]
      ,[Valid To]
      ,[Lineage Key]
  FROM [Dimension].[Customer]

SELECT TOP (1000) [Date]
      ,[Day Number]
      ,[Day]
      ,[Month]
      ,[Short Month]
      ,[Calendar Month Number]
      ,[Calendar Month Label]
      ,[Calendar Year]
      ,[Calendar Year Label]
      ,[Fiscal Month Number]
      ,[Fiscal Month Label]
      ,[Fiscal Year]
      ,[Fiscal Year Label]
      ,[ISO Week Number]
  FROM [Dimension].[Date]

SELECT TOP (1000) [Sale Key]
      ,[City Key]
      ,[Customer Key]
      ,[Bill To Customer Key]
      ,[Stock Item Key]
      ,[Invoice Date Key]
      ,[Delivery Date Key]
      ,[Salesperson Key]
      ,[WWI Invoice ID]
      ,[Description]
      ,[Package]
      ,[Quantity]
      ,[Unit Price]
      ,[Tax Rate]
      ,[Total Excluding Tax]
      ,[Tax Amount]
      ,[Profit]
      ,[Total Including Tax]
      ,[Total Dry Items]
      ,[Total Chiller Items]
      ,[Lineage Key]
  FROM [Fact].[Sale]

Acceptance criteria:
1.	The stored procedure should accept the following input parameters:
•	FromYear: integer; the year from which to start the calculation. 
Acceptable values: 2020, 2021, 2022, etc. If input parameter is not passed, the earliest available year in the data set should be used by default.
•	ToYear: integer; the year to which the calculation should be made. 
Acceptable values: 2020, 2021, 2022, etc. If input parameter is not passed, the latest available year in the data set should be used by default.
•	Period: varchar; period for which customer revenue should be aggregated (month, quarter, year). 
Acceptable values: ‘Month’, ’M’, ‘Quarter’, ‘Q’, ‘Year’, ‘Y’. If input parameter is not passed, year should be used by default.
•	CustomerID: integer; the ID of the customer for which revenue needs to be calculated. If the input parameter is not passed, all the customers should be included in the result set.
2.	The stored procedure should retrieve relevant sales data from the database based on the input parameters.
3.	The revenue should be calculated by summing the total sales amount for the specified customer within the given time period (based on the input parameter). The formula for sales amount is Quantity * Unit Price.
4.	The result set should be inserted to the newly created SQL table. The table should contain the following columns: 
•	[CustomerID] (int)
•	[CustomerName] (varchar(50))
•	[Period] (varchar(8))
•	[Revenue] (numeric(19,2))
5.	SQL table name should consist of customer ID, customer name, start year, end year and period identifier, for example: ‘1_SoftServe_2019_2022_M’ or ‘1_SoftServe_2019_2022_Q’ or ‘1_SoftServe_2019_2022_Y’.
If the stored procedure was executed for one year, table name should contain only one year, for example ‘1_SoftServe_2022_M’.
If stored procedure was executed for all customers, table name should contain prefix ‘All’, start year, end year and period identifier. For example, ‘All_2019_2022_Y’.
6.	The table should be created during each execution of stored procedure. If the table with the given name already exists – it should be dropped and recreated.
7.	Depends on the chosen period, periods data in the result set should be represented as following: 
•	For month: MM YYYY (for example, Jan 2022)
•	For quarter: ‘Q’+ QuarterNumber+ ‘ ‘ + YYYY (for example, Q1 2022)
•	For year: YYYY (for example, 2022)

8.	If no sales data is found for the specified customer within the given time period, the revenue should be set to zero.
9.	The stored procedure should handle any errors or exceptions and provide appropriate error messages. Errors should be written to [ErrorLog] table, which should contain following columns: 
•	[ErrorID] (int)
•	[ErrorNumber] (int)
•	[ErrorSeverity] (int)
•	[ErrorMessage] (varchar(255))
•	[CustomerID] (int)
•	[Period] (varchar(8))
•	[CreatedAt] (datetime)
The error table should be created during the first execution of stored procedure, so there should be the logic to check if error table already exists. 

Here is the example of result set, considering that stored procedure was executed using following values for input parameters:
FromYear = 2022
ToYear = 2022
Period = ‘M’
CustomerID = 342353

Quality rules: 
•	Stored procedure should be named as sp_CustomerRevenue.
•	Stored procedure should be written according to best coding practices, including naming conventions and comments. 
•	Stored procedure should be optimized to execute efficiently, ensuring minimal response time and resource consumption. 

Implement error handling logic in stored procedure

ChatGPT
Certainly! To create a stored procedure sp_CustomerRevenue that fulfills your requirements, you can follow these steps:

Input Parameters: Define the stored procedure with the required parameters.
Fetch Sales Data: Fetch the required sales data for the specified period, customer, and year range.
Revenue Calculation: Calculate the revenue based on the fetched sales data.
Table Creation: Create the result table based on the given naming conventions and parameters. Drop and recreate the table if it already exists.
Insert Data: Insert the calculated revenue into the result table.
Error Handling: Implement error handling to log errors in the ErrorLog table.
Below is the template of the stored procedure sp_CustomerRevenue:

sql
Copy code
CREATE PROCEDURE sp_CustomerRevenue
    @FromYear INT = NULL,
    @ToYear INT = NULL,
    @Period VARCHAR(8) = 'Y',
    @CustomerID INT = NULL
AS
BEGIN
    -- Declare variables
    DECLARE @StartDate DATE, @EndDate DATE, @TableName VARCHAR(100), @SQL NVARCHAR(MAX)

    -- Set the start and end dates based on the input parameters
    SET @StartDate = ISNULL(CONVERT(VARCHAR, @FromYear) + '0101', (SELECT MIN([Date]) FROM [Dimension].[Date]))
    SET @EndDate = ISNULL(CONVERT(VARCHAR, @ToYear) + '1231', (SELECT MAX([Date]) FROM [Dimension].[Date]))

    -- Set the table name based on the input parameters
    SET @TableName = ISNULL(CONVERT(VARCHAR, @CustomerID) + '_', 'All_') + 
                     CONVERT(VARCHAR, YEAR(@StartDate)) + '_' + 
                     CONVERT(VARCHAR, YEAR(@EndDate)) + '_' + 
                     LEFT(@Period, 1)

    -- Drop and recreate the result table
    SET @SQL = 'IF OBJECT_ID(''' + @TableName + ''') IS NOT NULL DROP TABLE ' + @TableName + ';
                CREATE TABLE ' + @TableName + ' (
                    [CustomerID] INT,
                    [CustomerName] VARCHAR(50),
                    [Period] VARCHAR(8),
                    [Revenue] NUMERIC(19,2)
                );'

    EXEC sp_executesql @SQL

    -- Fetch and insert the sales data into the result table
    INSERT INTO [dbo].[@TableName]
    SELECT 
        s.[Customer Key] AS [CustomerID],
        c.[Customer] AS [CustomerName],
        CASE @Period
            WHEN 'M' THEN FORMAT(d.[Date], 'MMM yyyy')
            WHEN 'Q' THEN 'Q' + CONVERT(VARCHAR, DATEPART(QUARTER, d.[Date])) + ' ' + CONVERT(VARCHAR, YEAR(d.[Date]))
            ELSE CONVERT(VARCHAR, YEAR(d.[Date]))
        END AS [Period],
        SUM(s.[Quantity] * s.[Unit Price]) AS [Revenue]
    FROM [Fact].[Sale] s
    JOIN [Dimension].[Customer] c ON s.[Customer Key] = c.[Customer Key]
    JOIN [Dimension].[Date] d ON s.[Invoice Date Key] = d.[Date]
    WHERE d.[Date] BETWEEN @StartDate AND @EndDate
    AND (@CustomerID IS NULL OR s.[Customer Key] = @CustomerID)
    GROUP BY 
        s.[Customer Key],
        c.[Customer],
        CASE @Period
            WHEN 'M' THEN FORMAT(d.[Date], 'MMM yyyy')
            WHEN 'Q' THEN 'Q' + CONVERT(VARCHAR, DATEPART(QUARTER, d.[Date])) + ' ' + CONVERT(VARCHAR, YEAR(d.[Date]))
            ELSE CONVERT(VARCHAR, YEAR(d.[Date]))
        END

    -- Handle no sales data case
    IF @@ROWCOUNT = 0
    BEGIN
        INSERT INTO [dbo].[@TableName] ([CustomerID], [CustomerName], [Period], [Revenue])
        VALUES (@CustomerID, (SELECT [Customer] FROM [Dimension].[Customer] WHERE [Customer Key] = @CustomerID), 
                CASE @Period
                    WHEN 'M' THEN FORMAT(@StartDate, 'MMM yyyy')
                    WHEN 'Q' THEN 'Q' + CONVERT(VARCHAR, DATEPART(QUARTER, @StartDate)) + ' ' + CONVERT(VARCHAR, YEAR(@StartDate))
                    ELSE CONVERT(VARCHAR, YEAR(@StartDate))
                END, 
                0)
    END

END
GO
Error Handling:
To handle errors and exceptions, you can add a TRY...CATCH block to the stored procedure. In the CATCH block, you can log the error details in the ErrorLog table. Here's how you can modify the stored procedure to include error handling:

sql
Copy code
BEGIN TRY
    -- Your existing code
    ...
END TRY
BEGIN CATCH
    -- Insert error details into ErrorLog table
    INSERT INTO [ErrorLog] ([ErrorNumber], [ErrorSeverity], [ErrorMessage], [CustomerID], [Period], [CreatedAt])
    VALUES (ERROR_NUMBER(), ERROR_SEVERITY(), ERROR_MESSAGE(), @CustomerID, @Period, GETDATE())
END CATCH
Make sure to create the ErrorLog table before executing the stored procedure. You can create the ErrorLog table using the following script:

sql
Copy code
CREATE TABLE [ErrorLog] (
    [ErrorID] INT PRIMARY KEY IDENTITY(1,1),
    [ErrorNumber] INT,
    [ErrorSeverity] INT,
    [ErrorMessage] VARCHAR(255),
    [CustomerID] INT,
    [Period] VARCHAR(8),
    [CreatedAt] DATETIME
)
Modify the sp_CustomerRevenue stored procedure accordingly to include error handling and execute the script to update the stored procedure in your database.




User
i need modify this procedure and Implement error handling logic. Also generate script for testing this procedure with different set of data
ChatGPT
Sure, you can modify the stored procedure to include error handling and then create a test script to test the stored procedure with different sets of data.

Modified stored procedure with error handling:

sql
Copy code
CREATE PROCEDURE sp_CustomerRevenue
    @FromYear INT = NULL,
    @ToYear INT = NULL,
    @Period VARCHAR(8) = 'Y',
    @CustomerID INT = NULL
AS
BEGIN
    BEGIN TRY
        -- Declare variables
        DECLARE @StartDate DATE, @EndDate DATE, @TableName VARCHAR(100), @SQL NVARCHAR(MAX)

        -- Set the start and end dates based on the input parameters
        SET @StartDate = ISNULL(CONVERT(VARCHAR, @FromYear) + '0101', (SELECT MIN([Date]) FROM [Dimension].[Date]))
        SET @EndDate = ISNULL(CONVERT(VARCHAR, @ToYear) + '1231', (SELECT MAX([Date]) FROM [Dimension].[Date]))

        -- Set the table name based on the input parameters
        SET @TableName = ISNULL(CONVERT(VARCHAR, @CustomerID) + '_', 'All_') + 
                         CONVERT(VARCHAR, YEAR(@StartDate)) + '_' + 
                         CONVERT(VARCHAR, YEAR(@EndDate)) + '_' + 
                         LEFT(@Period, 1)

        -- Drop and recreate the result table
        SET @SQL = 'IF OBJECT_ID(''' + @TableName + ''') IS NOT NULL DROP TABLE ' + @TableName + ';
                    CREATE TABLE ' + @TableName + ' (
                        [CustomerID] INT,
                        [CustomerName] VARCHAR(50),
                        [Period] VARCHAR(8),
                        [Revenue] NUMERIC(19,2)
                    );'

        EXEC sp_executesql @SQL

        -- Fetch and insert the sales data into the result table
        INSERT INTO [dbo].[@TableName]
        SELECT 
            s.[Customer Key] AS [CustomerID],
            c.[Customer] AS [CustomerName],
            CASE @Period
                WHEN 'M' THEN FORMAT(d.[Date], 'MMM yyyy')
                WHEN 'Q' THEN 'Q' + CONVERT(VARCHAR, DATEPART(QUARTER, d.[Date])) + ' ' + CONVERT(VARCHAR, YEAR(d.[Date]))
                ELSE CONVERT(VARCHAR, YEAR(d.[Date]))
            END AS [Period],
            SUM(s.[Quantity] * s.[Unit Price]) AS [Revenue]
        FROM [Fact].[Sale] s
        JOIN [Dimension].[Customer] c ON s.[Customer Key] = c.[Customer Key]
        JOIN [Dimension].[Date] d ON s.[Invoice Date Key] = d.[Date]
        WHERE d.[Date] BETWEEN @StartDate AND @EndDate
        AND (@CustomerID IS NULL OR s.[Customer Key] = @CustomerID)
        GROUP BY 
            s.[Customer Key],
            c.[Customer],
            CASE @Period
                WHEN 'M' THEN FORMAT(d.[Date], 'MMM yyyy')
                WHEN 'Q' THEN 'Q' + CONVERT(VARCHAR, DATEPART(QUARTER, d.[Date])) + ' ' + CONVERT(VARCHAR, YEAR(d.[Date]))
                ELSE CONVERT(VARCHAR, YEAR(d.[Date]))
            END

        -- Handle no sales data case
        IF @@ROWCOUNT = 0
        BEGIN
            INSERT INTO [dbo].[@TableName] ([CustomerID], [CustomerName], [Period], [Revenue])
            VALUES (@CustomerID, (SELECT [Customer] FROM [Dimension].[Customer] WHERE [Customer Key] = @CustomerID), 
                    CASE @Period
                        WHEN 'M' THEN FORMAT(@StartDate, 'MMM yyyy')
                        WHEN 'Q' THEN 'Q' + CONVERT(VARCHAR, DATEPART(QUARTER, @StartDate)) + ' ' + CONVERT(VARCHAR, YEAR(@StartDate))
                        ELSE CONVERT(VARCHAR, YEAR(@StartDate))
                    END, 
                    0)
        END
    END TRY
    BEGIN CATCH
        -- Insert error details into ErrorLog table
        INSERT INTO [ErrorLog] ([ErrorNumber], [ErrorSeverity], [ErrorMessage], [CustomerID], [Period], [CreatedAt])
        VALUES (ERROR_NUMBER(), ERROR_SEVERITY(), ERROR_MESSAGE(), @CustomerID, @Period, GETDATE())
    END CATCH
END
GO
Test script for the stored procedure:

sql
Copy code
-- Create ErrorLog table
CREATE TABLE [ErrorLog] (
    [ErrorID] INT PRIMARY KEY IDENTITY(1,1),
    [ErrorNumber] INT,
    [ErrorSeverity] INT,
    [ErrorMessage] VARCHAR(255),
    [CustomerID] INT,
    [Period] VARCHAR(8),
    [CreatedAt] DATETIME
)

-- Test the stored procedure with different sets of data
EXEC sp_CustomerRevenue @FromYear = 2022, @ToYear = 2022, @Period = 'M', @CustomerID = 342353
EXEC sp_CustomerRevenue @FromYear = 2021, @ToYear = 2022, @Period = 'Q'
EXEC sp_CustomerRevenue @FromYear = 2020, @Period = 'Y', @CustomerID = 123456
EXEC sp_CustomerRevenue @ToYear = 2022, @CustomerID = 789101
EXEC sp_CustomerRevenue

-- Check the ErrorLog table for any errors
SELECT * FROM [ErrorLog]
In this test script, the sp_CustomerRevenue stored procedure is executed five times with different sets of input parameters. After executing the test script, you can check the ErrorLog table for any errors that may have occurred during the execution of the stored procedure.




User
Msg 208, Level 16, State 1, Procedure sp_CustomerRevenue, Line 33 [Batch Start Line 16]
Invalid object name 'dbo.@TableName'.
ChatGPT
Apologies for the confusion. The error is due to using a variable for the table name. You cannot use variables for table names in a SQL statement without using dynamic SQL.

However, using dynamic SQL to create a table with a variable name, and then inserting data into that table within the same stored procedure can get quite complicated. Instead, it might be better to reconsider your design.

Creating a large number of tables with the same structure but different names is generally not a good practice. It would be better to have a single table that includes all the information, and then create a view or a query that selects the relevant data from that table.

For example, the single table could include columns for the start and end years, and the period, in addition to the customer ID, customer name, and revenue.

The table creation and data insertion part of the stored procedure could then look something like this:

sql
Copy code
-- Check if the result table exists, if not create it
IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'CustomerRevenue')
BEGIN
    CREATE TABLE [CustomerRevenue] (
        [CustomerID] INT,
        [CustomerName] VARCHAR(50),
        [StartYear] INT,
        [EndYear] INT,
        [Period] VARCHAR(8),
        [Revenue] NUMERIC(19,2)
    )
END

-- Fetch and insert the sales data into the result table
INSERT INTO [CustomerRevenue]
SELECT 
    s.[Customer Key] AS [CustomerID],
    c.[Customer] AS [CustomerName],
    YEAR(@StartDate) AS [StartYear],
    YEAR(@EndDate) AS [EndYear],
    @Period,
    SUM(s.[Quantity] * s.[Unit Price]) AS [Revenue]
FROM [Fact].[Sale] s
JOIN [Dimension].[Customer] c ON s.[Customer Key] = c.[Customer Key]
JOIN [Dimension].[Date] d ON s.[Invoice Date Key] = d.[Date]
WHERE d.[Date] BETWEEN @StartDate AND @EndDate
AND (@CustomerID IS NULL OR s.[Customer Key] = @CustomerID)
GROUP BY 
    s.[Customer Key],
    c.[Customer],
    YEAR(@StartDate),
    YEAR(@EndDate),
    @Period
Then, when you want to retrieve the data for a specific customer, start year, end year, and period, you can create a view or a query that selects the relevant data from the CustomerRevenue table.




User
can you rewrite sp_CustomerRevenue to avoid this error Msg 208, Level 16, State 1, Procedure sp_CustomerRevenue, Line 33 [Batch Start Line 16]
Invalid object name 'dbo.@TableName'.
ChatGPT
Sure, here's how you can modify your sp_CustomerRevenue stored procedure to avoid the error, and also to include error handling.

sql
Copy code
CREATE PROCEDURE sp_CustomerRevenue 
    @FromYear INT = NULL,
    @ToYear INT = NULL,
    @Period VARCHAR(50) = 'Year',
    @CustomerID INT = NULL
AS
BEGIN
    SET NOCOUNT ON;
    
    -- Declare variables
    DECLARE @StartDate DATE, @EndDate DATE;
    DECLARE @TableName NVARCHAR(128);
    DECLARE @SQL NVARCHAR(MAX);
    
    -- Set start and end dates based on input parameters
    IF @FromYear IS NULL
        SET @StartDate = (SELECT MIN([Date]) FROM [Dimension].[Date]);
    ELSE
        SET @StartDate = CAST(CAST(@FromYear AS NVARCHAR) + '0101' AS DATE);
    
    IF @ToYear IS NULL
        SET @EndDate = (SELECT MAX([Date]) FROM [Dimension].[Date]);
    ELSE
        SET @EndDate = CAST(CAST(@ToYear AS NVARCHAR) + '1231' AS DATE);
    
    -- Set table name based on input parameters
    IF @CustomerID IS NULL
        SET @TableName = 'All_' + CAST(@FromYear AS NVARCHAR) + '_' + CAST(@ToYear AS NVARCHAR) + '_' + @Period;
    ELSE
        SET @TableName = CAST(@CustomerID AS NVARCHAR) + '_' + 
                         (SELECT [Customer] FROM [Dimension].[Customer] WHERE [Customer Key] = @CustomerID) + '_' +
                         CAST(@FromYear AS NVARCHAR) + '_' + CAST(@ToYear AS NVARCHAR) + '_' + @Period;
    
    -- Drop table if it already exists
    SET @SQL = 'IF OBJECT_ID(''' + @TableName + ''', ''U'') IS NOT NULL DROP TABLE ' + @TableName;
    EXEC sp_executesql @SQL;
    
    -- Create result table
    SET @SQL = 'CREATE TABLE ' + @TableName + ' (' +
               '[CustomerID] INT, ' +
               '[CustomerName] VARCHAR(50), ' +
               '[Period] VARCHAR(8), ' +
               '[Revenue] NUMERIC(19,2))';
    EXEC sp_executesql @SQL;
    
    -- Insert data into result table
    SET @SQL = 'INSERT INTO ' + @TableName + ' ' +
               'SELECT ' +
               '    s.[Customer Key] AS [CustomerID], ' +
               '    c.[Customer] AS [CustomerName], ' +
               '    CASE ' +
               '        WHEN ''' + @Period + ''' = ''Month'' THEN FORMAT(d.[Date], ''MMM yyyy'') ' +
               '        WHEN ''' + @Period + ''' = ''Quarter'' THEN ''Q'' + CAST(DATEPART(QUARTER, d.[Date]) AS NVARCHAR) + '' '' + CAST(YEAR(d.[Date]) AS NVARCHAR) ' +
               '        ELSE CAST(YEAR(d.[Date]) AS NVARCHAR) ' +
               '    END AS [Period], ' +
               '    SUM(s.[Quantity] * s.[Unit Price]) AS [Revenue] ' +
               'FROM [Fact].[Sale] s ' +
               'JOIN [Dimension].[Customer] c ON s.[Customer Key] = c.[Customer Key] ' +
               'JOIN [Dimension].[Date] d ON s.[Invoice Date Key] = d.[Date] ' +
               'WHERE d.[Date] BETWEEN ''' + CAST(@StartDate AS NVARCHAR) + ''' AND ''' + CAST(@EndDate AS NVARCHAR) + ''' ' +
               'AND (s.[Customer Key] = ' + CAST(@CustomerID AS NVARCHAR) + ' OR ' + CAST(@CustomerID AS NVARCHAR) + ' IS NULL) ' +
               'GROUP BY ' +
               '    s.[Customer Key], ' +
               '    c.[Customer], ' +
               '    CASE ' +
               '        WHEN ''' + @Period + ''' = ''Month'' THEN FORMAT(d.[Date], ''MMM yyyy'') ' +
               '        WHEN ''' + @Period + ''' = ''Quarter'' THEN ''Q'' + CAST(DATEPART(QUARTER, d.[Date]) AS NVARCHAR) + '' '' + CAST(YEAR(d.[Date]) AS NVARCHAR) ' +
               '        ELSE CAST(YEAR(d.[Date]) AS NVARCHAR) ' +
               '    END';
    EXEC sp_executesql @SQL;
    
    -- Check if error table exists, if not create it
    IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'ErrorLog')
    BEGIN
        CREATE TABLE [ErrorLog] (
            [ErrorID] INT IDENTITY(1,1),
            [ErrorNumber] INT,
            [ErrorSeverity] INT,
            [ErrorMessage] VARCHAR(255),
            [CustomerID] INT,
            [Period] VARCHAR(8),
            [CreatedAt] DATETIME
        )
    END
    
    -- Error handling
    BEGIN TRY
        -- Your code here
        
    END TRY
    BEGIN CATCH
        INSERT INTO [ErrorLog]
        VALUES (
            ERROR_NUMBER(),
            ERROR_SEVERITY(),
            ERROR_MESSAGE(),
            @CustomerID,
            @Period,
            GETDATE()
        )
    END CATCH
END
In this revised procedure, the @TableName variable is used to create and insert data into a table with a dynamic name, based on the input parameters. The @SQL variable is used to store the dynamic SQL statements, which are then executed using the sp_executesql system stored procedure. The error handling section has also been updated to include the ErrorLog table creation and the error catching logic.




User
i got this error when trying to create procedure
Msg 102, Level 15, State 1, Procedure sp_CustomerRevenue, Line 90 [Batch Start Line 75]
Incorrect syntax near 'TRY'.
Msg 102, Level 15, State 1, Procedure sp_CustomerRevenue, Line 101 [Batch Start Line 75]
Incorrect syntax near 'CATCH'.
ChatGPT
The TRY...CATCH block should enclose some SQL code in the TRY block. Currently, the TRY block is empty which is causing the syntax error. You should put all the main logic of your procedure inside the TRY block and error handling logic in the CATCH block.

Here is how you modify the procedure:

sql
Copy code
...

    -- Error handling
    BEGIN TRY
        -- Your main code here
        
        -- Insert data into result table
        SET @SQL = 'INSERT INTO ' + @TableName + ' ' +
                   'SELECT ' +
                   ...
                   '    END';
        EXEC sp_executesql @SQL;
        
    END TRY
    BEGIN CATCH
        INSERT INTO [ErrorLog]
        VALUES (
            ERROR_NUMBER(),
            ERROR_SEVERITY(),
            ERROR_MESSAGE(),
            @CustomerID,
            @Period,
            GETDATE()
        )
    END CATCH
END
I have moved the INSERT logic inside the TRY block. You should put all other logic that could potentially raise an error inside the TRY block. This way, if any part of your code throws an error, it will immediately jump to the CATCH block and log the error in the ErrorLog table.




User
during testing of stored procedure i got empty tables with no data inserted

let's revise procedure 
Acceptance criteria:
1.	The stored procedure should accept the following input parameters:
•	FromYear: integer; the year from which to start the calculation. 
Acceptable values: 2020, 2021, 2022, etc. If input parameter is not passed, the earliest available year in the data set should be used by default.
•	ToYear: integer; the year to which the calculation should be made. 
Acceptable values: 2020, 2021, 2022, etc. If input parameter is not passed, the latest available year in the data set should be used by default.
•	Period: varchar; period for which customer revenue should be aggregated (month, quarter, year). 
Acceptable values: ‘Month’, ’M’, ‘Quarter’, ‘Q’, ‘Year’, ‘Y’. If input parameter is not passed, year should be used by default.
•	CustomerID: integer; the ID of the customer for which revenue needs to be calculated. If the input parameter is not passed, all the customers should be included in the result set.
2.	The stored procedure should retrieve relevant sales data from the database based on the input parameters.
3.	The revenue should be calculated by summing the total sales amount for the specified customer within the given time period (based on the input parameter). The formula for sales amount is Quantity * Unit Price.
4.	The result set should be inserted to the newly created SQL table. The table should contain the following columns: 
•	[CustomerID] (int)
•	[CustomerName] (varchar(50))
•	[Period] (varchar(8))
•	[Revenue] (numeric(19,2))
5.	SQL table name should consist of customer ID, customer name, start year, end year and period identifier, for example: ‘1_SoftServe_2019_2022_M’ or ‘1_SoftServe_2019_2022_Q’ or ‘1_SoftServe_2019_2022_Y’.
If the stored procedure was executed for one year, table name should contain only one year, for example ‘1_SoftServe_2022_M’.
If stored procedure was executed for all customers, table name should contain prefix ‘All’, start year, end year and period identifier. For example, ‘All_2019_2022_Y’.
6.	The table should be created during each execution of stored procedure. If the table with the given name already exists – it should be dropped and recreated.
7.	Depends on the chosen period, periods data in the result set should be represented as following: 
•	For month: MM YYYY (for example, Jan 2022)
•	For quarter: ‘Q’+ QuarterNumber+ ‘ ‘ + YYYY (for example, Q1 2022)
•	For year: YYYY (for example, 2022)

8.	If no sales data is found for the specified customer within the given time period, the revenue should be set to zero.
ChatGPT
Creating a stored procedure with the requirements and the acceptance criteria you provided can be quite extensive. Below is a template to start with, but it may require some further modifications and thorough testing to make sure it fits your exact needs.

sql
Copy code
CREATE PROCEDURE sp_CustomerRevenue
    @FromYear INT = NULL,
    @ToYear INT = NULL,
    @Period VARCHAR(10) = 'Y',
    @CustomerID INT = NULL
AS
BEGIN
    SET NOCOUNT ON;
    
    DECLARE @StartDate DATE, @EndDate DATE;
    DECLARE @TableName NVARCHAR(128), @SQL NVARCHAR(MAX);
    
    -- Set the start and end dates based on the input parameters
    SET @StartDate = ISNULL(CAST(@FromYear AS CHAR(4)) + '0101', (SELECT MIN([Date]) FROM [Dimension].[Date]));
    SET @EndDate = ISNULL(CAST(@ToYear AS CHAR(4)) + '1231', (SELECT MAX([Date]) FROM [Dimension].[Date]));
    
    -- Create the table name based on the input parameters
    SET @TableName = 'Revenue_';
    IF @CustomerID IS NULL
        SET @TableName += 'All';
    ELSE
        SET @TableName += CAST(@CustomerID AS NVARCHAR);
    SET @TableName += '_' + REPLACE(CONVERT(VARCHAR, @StartDate, 120), '-', '_');
    SET @TableName += '_' + REPLACE(CONVERT(VARCHAR, @EndDate, 120), '-', '_');
    SET @TableName += '_' + LEFT(@Period, 1);
    
    -- Drop the table if it already exists
    SET @SQL = 'IF OBJECT_ID(''dbo.' + @TableName + ''', ''U'') IS NOT NULL ' +
               'DROP TABLE dbo.' + @TableName;
    EXEC sp_executesql @SQL;
    
    -- Create the table
    SET @SQL = 'CREATE TABLE dbo.' + @TableName + ' ' +
               '([CustomerID] INT, ' +
               '[CustomerName] VARCHAR(50), ' +
               '[Period] VARCHAR(8), ' +
               '[Revenue] NUMERIC(19,2))';
    EXEC sp_executesql @SQL;
    
    -- Insert the revenue data into the table
    SET @SQL = 'INSERT INTO dbo.' + @TableName + ' ' +
               'SELECT ' +
               '    c.[WWI Customer ID] AS [CustomerID], ' +
               '    c.[Customer] AS [CustomerName], ' +
               '    CASE ' +
               '        WHEN @Period IN (''Month'', ''M'') THEN FORMAT(d.[Date], ''MMM yyyy'') ' +
               '        WHEN @Period IN (''Quarter'', ''Q'') THEN ''Q'' + CAST(DATEPART(QUARTER, d.[Date]) AS VARCHAR) + '' '' + CAST(DATEPART(YEAR, d.[Date]) AS VARCHAR) ' +
               '        ELSE CAST(DATEPART(YEAR, d.[Date]) AS VARCHAR) ' +
               '    END AS [Period], ' +
               '    ISNULL(SUM(s.[Quantity] * s.[Unit Price]), 0) AS [Revenue] ' +
               'FROM ' +
               '    [Dimension].[Customer] c ' +
               'LEFT JOIN ' +
               '    [Fact].[Sale] s ON c.[Customer Key] = s.[Customer Key] ' +
               'LEFT JOIN ' +
               '    [Dimension].[Date] d ON s.[Invoice Date Key] = d.[Date] ' +
               'WHERE ' +
               '    d.[Date] BETWEEN @StartDate AND @EndDate ' +
               '    AND (@CustomerID IS NULL OR c.[WWI Customer ID] = @CustomerID) ' +
               'GROUP BY ' +
               '    c.[WWI Customer ID], c.[Customer], d.[Date]';
    EXEC sp_executesql @SQL, N'@StartDate DATE, @EndDate DATE, @Period VARCHAR(10), @CustomerID INT', @StartDate, @EndDate, @Period, @CustomerID;
    
    -- Check if there was any error
    IF @@ERROR <> 0
    BEGIN
        -- Log the error into the ErrorLog table
        INSERT INTO [ErrorLog]
        VALUES (
            ERROR_NUMBER(),
            ERROR_SEVERITY(),
            ERROR_MESSAGE(),
            @CustomerID,
            @Period,
            GETDATE()
        )
        
        -- Rollback the transaction
        ROLLBACK TRANSACTION;
    END
    
    SET NOCOUNT OFF;
END
This script creates a stored procedure named sp_CustomerRevenue that accepts four parameters: FromYear, ToYear, Period, and CustomerID. The procedure calculates the total revenue generated by a customer or all customers within a specific time period and inserts the result into a newly created table. The table name is generated based on the input parameters. If the table already exists, it will be dropped and recreated.

The Period parameter accepts the values 'Month', 'M', 'Quarter', 'Q', 'Year', and 'Y'. The result set will be aggregated based on this parameter. If no sales data is found for the specified customer and time period, the revenue will be set to zero. If any error occurs during the execution, it will be logged into the ErrorLog table.

You can test the procedure by executing it with different sets of parameters, for example:

sql
Copy code
EXEC sp_CustomerRevenue @FromYear = 2022, @ToYear = 2022, @Period = 'M', @CustomerID = 342353;
Please adjust the script according to your needs and test it thoroughly before using it in a production environment.




User
when i run stored procedure it creates tables with not appropriate names
based on given tables join Customer with Sale ON Customer Key, and join Sale with Date ON Date=Invoice Date Key,  then after join with Date you will recieve Short Month, Day and year needed for naming table

so need to create procedure:
 1.	The stored procedure should accept the following input parameters:
•	FromYear: integer; the year from which to start the calculation. 
Acceptable values: 2020, 2021, 2022, etc. If input parameter is not passed, the earliest available year in the data set should be used by default.
•	ToYear: integer; the year to which the calculation should be made. 
Acceptable values: 2020, 2021, 2022, etc. If input parameter is not passed, the latest available year in the data set should be used by default.
•	Period: varchar; period for which customer revenue should be aggregated (month, quarter, year). 
Acceptable values: ‘Month’, ’M’, ‘Quarter’, ‘Q’, ‘Year’, ‘Y’. If input parameter is not passed, year should be used by default.
•	CustomerID: integer; the ID of the customer for which revenue needs to be calculated. If the input parameter is not passed, all the customers should be included in the result set.

based on input parameters you should create 
SQL table name should consist of customer ID, customer name, start year, end year and period identifier, for example: ‘379_JuliaF_2019_2022_M’ or ‘1_JuliaF_2019_2022_Q’ or ‘1_SoftServe_2019_2022_Y’.
where 379 - customer key
JuliaF - customer name

If the stored procedure was executed for one year, table name should contain only one year, for example ‘1_SoftServe_2022_M’.
If stored procedure was executed for all customers, table name should contain prefix ‘All’, start year, end year and period identifier. For example, ‘All_2019_2022_Y’.
6.	The table should be created during each execution of stored procedure. If the table with the given name already exists – it should be dropped and recreated.
7.	Depends on the chosen period, periods data in the result set should be represented as following: 
•	For month: MM YYYY (for example, Jan 2022)
•	For quarter: ‘Q’+ QuarterNumber+ ‘ ‘ + YYYY (for example, Q1 2022)
•	For year: YYYY (for example, 2022)

ChatGPT
Sure, here is an example stored procedure that should meet your criteria:

sql
Copy code
CREATE PROCEDURE sp_CustomerRevenue
    @FromYear INT = NULL,
    @ToYear INT = NULL,
    @Period VARCHAR(10) = 'Y',
    @CustomerID INT = NULL
AS
BEGIN
    SET NOCOUNT ON;
    
    DECLARE @StartDate DATE, @EndDate DATE;
    DECLARE @TableName NVARCHAR(128), @SQL NVARCHAR(MAX);
    DECLARE @CustomerName NVARCHAR(50);
    
    -- Set the start and end dates based on the input parameters
    SET @StartDate = ISNULL(CAST(@FromYear AS CHAR(4)) + '0101', (SELECT MIN([Date]) FROM [Sales].[Date]));
    SET @EndDate = ISNULL(CAST(@ToYear AS CHAR(4)) + '1231', (SELECT MAX([Date]) FROM [Sales].[Date]));
    
    -- Get the customer name if a CustomerID is provided
    SET @CustomerName = (SELECT [Name] FROM [Sales].[Customer] WHERE [Customer Key] = @CustomerID);
    
    -- Create the table name based on the input parameters
    IF @CustomerID IS NULL
        SET @TableName = 'All';
    ELSE
        SET @TableName = CAST(@CustomerID AS NVARCHAR) + '_' + REPLACE(@CustomerName, ' ', '');
    IF @FromYear = @ToYear
        SET @TableName += '_' + CAST(@FromYear AS NVARCHAR);
    ELSE
        SET @TableName += '_' + CAST(@FromYear AS NVARCHAR) + '_' + CAST(@ToYear AS NVARCHAR);
    SET @TableName += '_' + LEFT(@Period, 1);
    
    -- Drop the table if it already exists
    SET @SQL = 'IF OBJECT_ID(''dbo.' + @TableName + ''', ''U'') IS NOT NULL ' +
               'DROP TABLE dbo.' + @TableName;
    EXEC sp_executesql @SQL;
    
    -- Create the table
    SET @SQL = 'CREATE TABLE dbo.' + @TableName + ' ' +
               '([CustomerID] INT, ' +
               '[CustomerName] NVARCHAR(50), ' +
               '[Period] NVARCHAR(8), ' +
               '[Revenue] NUMERIC(19,2))';
    EXEC sp_executesql @SQL;
    
    -- Insert the revenue data into the table
    SET @SQL = 'INSERT INTO dbo.' + @TableName + ' ' +
               'SELECT ' +
               '    c.[Customer Key] AS [CustomerID], ' +
               '    c.[Name] AS [CustomerName], ' +
               '    CASE ' +
               '        WHEN @Period IN (''Month'', ''M'') THEN FORMAT(d.[Date], ''MMM yyyy'') ' +
               '        WHEN @Period IN (''Quarter'', ''Q'') THEN ''Q'' + CAST(DATEPART(QUARTER, d.[Date]) AS NVARCHAR) + '' '' + CAST(DATEPART(YEAR, d.[Date]) AS NVARCHAR) ' +
               '        ELSE CAST(DATEPART(YEAR, d.[Date]) AS NVARCHAR) ' +
               '    END AS [Period], ' +
               '    ISNULL(SUM(s.[Quantity] * s.[Unit Price]), 0) AS [Revenue] ' +
               'FROM ' +
               '    [Sales].[Customer] c ' +
               'LEFT JOIN ' +
               '    [Sales].[Sale] s ON c.[Customer Key] = s.[Customer Key] ' +
               'LEFT JOIN ' +
               '    [Sales].[Date] d ON s.[Invoice Date Key] = d.[Date] ' +
               'WHERE ' +
               '    d.[Date] BETWEEN @StartDate AND @EndDate ' +
               '    AND (@CustomerID IS NULL OR c.[Customer Key] = @CustomerID) ' +
               'GROUP BY ' +
               '    c.[Customer Key], c.[Name], d.[Date]';
    EXEC sp_executesql @SQL, N'@StartDate DATE, @EndDate DATE, @Period NVARCHAR(10), @CustomerID INT', @StartDate, @EndDate, @Period, @CustomerID;
    
    SET NOCOUNT OFF;
END
You can then call the stored procedure like this:

sql
Copy code
EXEC sp_CustomerRevenue @FromYear = 2022, @ToYear = 2022, @Period = 'M', @CustomerID = 1;
This will create a table named 1_CustomerName_2022_M with the aggregated revenue data for the specified customer and time period.

Please adjust the script according to your needs and test it thoroughly before using it in a production environment.




User
please rewrite names of table and schema Dimention.Date , Dimention.Customer, Fact.Sale
ChatGPT
Sure, the revised stored procedure with the updated table and schema names is as follows:

sql
Copy code
CREATE PROCEDURE sp_CustomerRevenue
    @FromYear INT = NULL,
    @ToYear INT = NULL,
    @Period VARCHAR(10) = 'Y',
    @CustomerID INT = NULL
AS
BEGIN
    SET NOCOUNT ON;
    
    DECLARE @StartDate DATE, @EndDate DATE;
    DECLARE @TableName NVARCHAR(128), @SQL NVARCHAR(MAX);
    DECLARE @CustomerName NVARCHAR(50);
    
    -- Set the start and end dates based on the input parameters
    SET @StartDate = ISNULL(CAST(@FromYear AS CHAR(4)) + '0101', (SELECT MIN([Date]) FROM [Dimention].[Date]));
    SET @EndDate = ISNULL(CAST(@ToYear AS CHAR(4)) + '1231', (SELECT MAX([Date]) FROM [Dimention].[Date]));
    
    -- Get the customer name if a CustomerID is provided
    SET @CustomerName = (SELECT [Name] FROM [Dimention].[Customer] WHERE [Customer Key] = @CustomerID);
    
    -- Create the table name based on the input parameters
    IF @CustomerID IS NULL
        SET @TableName = 'All';
    ELSE
        SET @TableName = CAST(@CustomerID AS NVARCHAR) + '_' + REPLACE(@CustomerName, ' ', '');
    IF @FromYear = @ToYear
        SET @TableName += '_' + CAST(@FromYear AS NVARCHAR);
    ELSE
        SET @TableName += '_' + CAST(@FromYear AS NVARCHAR) + '_' + CAST(@ToYear AS NVARCHAR);
    SET @TableName += '_' + LEFT(@Period, 1);
    
    -- Drop the table if it already exists
    SET @SQL = 'IF OBJECT_ID(''dbo.' + @TableName + ''', ''U'') IS NOT NULL ' +
               'DROP TABLE dbo.' + @TableName;
    EXEC sp_executesql @SQL;
    
    -- Create the table
    SET @SQL = 'CREATE TABLE dbo.' + @TableName + ' ' +
               '([CustomerID] INT, ' +
               '[CustomerName] NVARCHAR(50), ' +
               '[Period] NVARCHAR(8), ' +
               '[Revenue] NUMERIC(19,2))';
    EXEC sp_executesql @SQL;
    
    -- Insert the revenue data into the table
    SET @SQL = 'INSERT INTO dbo.' + @TableName + ' ' +
               'SELECT ' +
               '    c.[Customer Key] AS [CustomerID], ' +
               '    c.[Name] AS [CustomerName], ' +
               '    CASE ' +
               '        WHEN @Period IN (''Month'', ''M'') THEN FORMAT(d.[Date], ''MMM yyyy'') ' +
               '        WHEN @Period IN (''Quarter'', ''Q'') THEN ''Q'' + CAST(DATEPART(QUARTER, d.[Date]) AS NVARCHAR) + '' '' + CAST(DATEPART(YEAR, d.[Date]) AS NVARCHAR) ' +
               '        ELSE CAST(DATEPART(YEAR, d.[Date]) AS NVARCHAR) ' +
               '    END AS [Period], ' +
               '    ISNULL(SUM(s.[Quantity] * s.[Unit Price]), 0) AS [Revenue] ' +
               'FROM ' +
               '    [Dimention].[Customer] c ' +
               'LEFT JOIN ' +
               '    [Fact].[Sale] s ON c.[Customer Key] = s.[Customer Key] ' +
               'LEFT JOIN ' +
               '    [Dimention].[Date] d ON s.[Invoice Date Key] = d.[Date] ' +
               'WHERE ' +
               '    d.[Date] BETWEEN @StartDate AND @EndDate ' +
               '    AND (@CustomerID IS NULL OR c.[Customer Key] = @CustomerID) ' +
               'GROUP BY ' +
               '    c.[Customer Key], c.[Name], d.[Date]';
    EXEC sp_executesql @SQL, N'@StartDate DATE, @EndDate DATE, @Period NVARCHAR(10), @CustomerID INT', @StartDate, @EndDate, @Period, @CustomerID;
    
    SET NOCOUNT OFF;
END
You can call the procedure as previously described. This script will create a table with the aggregated revenue data for the specified customer and time period based on the given input parameters. Please test it thoroughly before using it in a production environment.




User
when i run sp with this parameters 
EXEC sp_CustomerRevenue @FromYear = 2013, @ToYear = 2014, @Period = 'M', @CustomerID = 379;
i got Incorrect syntax near '.379'
ChatGPT
The error you are encountering is due to the fact that table names in SQL Server must follow the rules for identifiers and cannot start with a digit, so you can't have a table name starting with a number. It is also not recommended to have special characters in table names.

Instead, I would suggest prefixing the table name with a constant string, for example 'Revenue_'.

Here is the modified part of the stored procedure that creates the table name:

sql
Copy code
    -- Create the table name based on the input parameters
    SET @TableName = 'Revenue_';
    IF @CustomerID IS NULL
        SET @TableName += 'All';
    ELSE
        SET @TableName += CAST(@CustomerID AS NVARCHAR) + '_' + REPLACE(@CustomerName, ' ', '');
    IF @FromYear = @ToYear
        SET @TableName += '_' + CAST(@FromYear AS NVARCHAR);
    ELSE
        SET @TableName += '_' + CAST(@FromYear AS NVARCHAR) + '_' + CAST(@ToYear AS NVARCHAR);
    SET @TableName += '_' + LEFT(@Period, 1);
This way, the table name will be something like 'Revenue_379_JuliaF_2013_2014_M', which is a valid table name in SQL Server. Make sure to apply this modification and test the stored procedure again.




User
if customer name has value: Wingtip Toys (Bell Acres, PA)
i need to trim commas and ()
ChatGPT
To remove certain characters from a string in SQL Server, you can use the REPLACE function multiple times to replace each unwanted character with an empty string.

For example, to remove commas, parentheses, and spaces from a string, you can do the following:

sql
Copy code
SET @String = REPLACE(REPLACE(REPLACE(REPLACE(@String, '(', ''), ')', ''), ',', ''), ' ', '');
Here is how you can apply it to the @CustomerName variable in your stored procedure:

sql
Copy code
SET @CustomerName = REPLACE(REPLACE(REPLACE(REPLACE(@CustomerName, '(', ''), ')', ''), ',', ''), ' ', '');
So, the part of the stored procedure that creates the table name will look like this:

sql
Copy code
    -- Create the table name based on the input parameters
    SET @TableName = 'Revenue_';
    IF @CustomerID IS NULL
        SET @TableName += 'All';
    ELSE
    BEGIN
        SET @CustomerName = REPLACE(REPLACE(REPLACE(REPLACE(@CustomerName, '(', ''), ')', ''), ',', ''), ' ', '');
        SET @TableName += CAST(@CustomerID AS NVARCHAR) + '_' + @CustomerName;
    END
    IF @FromYear = @ToYear
        SET @TableName += '_' + CAST(@FromYear AS NVARCHAR);
    ELSE
        SET @TableName += '_' + CAST(@FromYear AS NVARCHAR) + '_' + CAST(@ToYear AS NVARCHAR);
    SET @TableName += '_' + LEFT(@Period, 1);
Now the @CustomerName variable will not contain any parentheses, commas, or spaces, and the table name will be created correctly.




User
when i run EXEC sp_CustomerRevenue @ToYear = 2013, @CustomerID = '376'
Msg 241, Level 16, State 1, Procedure sp_CustomerRevenue, Line 15 [Batch Start Line 15]
Conversion failed when converting date and/or time from character string.
ChatGPT
It looks like the stored procedure is having trouble converting a value to a date/time data type. This could be caused by an incorrect value in the database, or by an incorrect format used in the stored procedure.

To help you further, I'll need to see the relevant parts of your stored procedure where the conversion is taking place, and also the data that is being used.

Meanwhile, you can try to identify the issue by adding some PRINT statements in your stored procedure to output the values that are being converted, and then see which one is causing the problem.

Here is a template for your stored procedure based on your requirements:

sql
Copy code
CREATE PROCEDURE sp_CustomerRevenue
    @FromYear INT = NULL,
    @ToYear INT = NULL,
    @Period VARCHAR(10) = 'Y',
    @CustomerID INT = NULL
AS
BEGIN
    SET NOCOUNT



User
CREATE OR ALTER PROCEDURE sp_CustomerRevenue
    @FromYear INT = NULL,
    @ToYear INT = NULL,
    @Period VARCHAR(10) = 'Y',
    @CustomerID INT = NULL
AS
BEGIN
    SET NOCOUNT ON;
    
    DECLARE @StartDate DATE, @EndDate DATE;
    DECLARE @TableName NVARCHAR(128), @SQL NVARCHAR(MAX);
    DECLARE @CustomerName NVARCHAR(50);
    
    -- Set the start and end dates based on the input parameters
    SET @StartDate = ISNULL(CAST(@FromYear AS CHAR(4)) + '0101', (SELECT MIN([Date]) FROM [Dimension].[Date]));
    SET @EndDate = ISNULL(CAST(@ToYear AS CHAR(4)) + '1231', (SELECT MAX([Date]) FROM [Dimension].[Date]));
    
    -- Get the customer name if a CustomerID is provided
    SET @CustomerName = (SELECT [Customer] FROM [Dimension].[Customer] WHERE [Customer Key] = @CustomerID);
    
    -- Create the table name based on the input parameters
    -- Create the table name based on the input parameters
    SET @TableName = 'Revenue_';
    IF @CustomerID IS NULL
        SET @TableName += 'All';
    ELSE
    BEGIN
        SET @CustomerName = REPLACE(REPLACE(REPLACE(REPLACE(@CustomerName, '(', ''), ')', ''), ',', ''), ' ', '');
        SET @TableName += CAST(@CustomerID AS NVARCHAR) + '_' + @CustomerName;
    END
    IF @FromYear = @ToYear
        SET @TableName += '_' + CAST(@FromYear AS NVARCHAR);
    ELSE
        SET @TableName += '_' + CAST(@FromYear AS NVARCHAR) + '_' + CAST(@ToYear AS NVARCHAR);
    SET @TableName += '_' + LEFT(@Period, 1);

    
    -- Drop the table if it already exists
    SET @SQL = 'IF OBJECT_ID(''dbo.' + @TableName + ''', ''U'') IS NOT NULL ' +
               'DROP TABLE dbo.' + @TableName;
    EXEC sp_executesql @SQL;
    
    -- Create the table
    SET @SQL = 'CREATE TABLE dbo.' + @TableName + ' ' +
               '([CustomerID] INT, ' +
               '[CustomerName] NVARCHAR(50), ' +
               '[Period] NVARCHAR(8), ' +
               '[Revenue] NUMERIC(19,2))';
    EXEC sp_executesql @SQL;
    
    -- Insert the revenue data into the table
    SET @SQL = 'INSERT INTO dbo.' + @TableName + ' ' +
               'SELECT ' +
               '    c.[Customer Key] AS [CustomerID], ' +
               '    c.[Customer] AS [CustomerName], ' +
               '    CASE ' +
               '        WHEN @Period IN (''Month'', ''M'') THEN FORMAT(d.[Date], ''MMM yyyy'') ' +
               '        WHEN @Period IN (''Quarter'', ''Q'') THEN ''Q'' + CAST(DATEPART(QUARTER, d.[Date]) AS NVARCHAR) + '' '' + CAST(DATEPART(YEAR, d.[Date]) AS NVARCHAR) ' +
               '        ELSE CAST(DATEPART(YEAR, d.[Date]) AS NVARCHAR) ' +
               '    END AS [Period], ' +
               '    ISNULL(SUM(s.[Quantity] * s.[Unit Price]), 0) AS [Revenue] ' +
               'FROM ' +
               '    [Dimension].[Customer] c ' +
               'LEFT JOIN ' +
               '    [Fact].[Sale] s ON c.[Customer Key] = s.[Customer Key] ' +
               'LEFT JOIN ' +
               '    [Dimension].[Date] d ON s.[Invoice Date Key] = d.[Date] ' +
               'WHERE ' +
               '    d.[Date] BETWEEN @StartDate AND @EndDate ' +
               '    AND (@CustomerID IS NULL OR c.[Customer Key] = @CustomerID) ' +
               'GROUP BY ' +
               '    c.[Customer Key], c.[Customer], d.[Date]';
    EXEC sp_executesql @SQL, N'@StartDate DATE, @EndDate DATE, @Period NVARCHAR(10), @CustomerID INT', @StartDate, @EndDate, @Period, @CustomerID;
    
    SET NOCOUNT OFF;
END


go

when i run EXEC sp_CustomerRevenue @ToYear = 2013, @CustomerID = 376
Msg 241, Level 16, State 1, Procedure sp_CustomerRevenue, Line 15 [Batch Start Line 15]
Conversion failed when converting date and/or time from character string.
ChatGPT
The error message you are getting indicates that there is an issue with converting a character string to a date and/or time value. This is likely occurring because of the @StartDate and @EndDate variables.

Since you are passing only the @ToYear parameter and the @CustomerID, the @FromYear parameter will be NULL. So, the @StartDate will be the minimum date from the Dimension.Date table. There might be a problem with the data in that table.

Please check the Dimension.Date table and make sure that all the values in the Date column are in a correct date format.

If the values are correct and you are still facing the issue, you can convert the Date column to NVARCHAR before converting it to DATE. Modify the following lines:

sql
Copy code
SET @StartDate = ISNULL(CAST(@FromYear AS CHAR(4)) + '0101', (SELECT MIN(CONVERT(NVARCHAR, [Date])) FROM [Dimension].[Date]));
SET @EndDate = ISNULL(CAST(@ToYear AS CHAR(4)) + '1231', (SELECT MAX(CONVERT(NVARCHAR, [Date])) FROM [Dimension].[Date]));
This modification will ensure that the Date column is first converted to NVARCHAR before converting it to DATE, which might solve the conversion issue. Please try making this change and running the stored procedure again.

Also, I noticed that you are creating the table using dynamic SQL. However, you are not using dynamic SQL to insert data into the table. The dynamic nature of the table name means you will have to use dynamic SQL for all operations related to that table.

In the -- Insert the revenue data into the table section, you will also need to use dynamic SQL.

Replace this part:

sql
Copy code
-- Insert the revenue data into the table
SET @SQL = 'INSERT INTO dbo.' + @TableName + ' ' +
           ...
EXEC sp_executesql @SQL, N'@StartDate DATE, @EndDate DATE, @Period NVARCHAR(10), @CustomerID INT', @StartDate, @EndDate, @Period, @CustomerID;
with:

sql
Copy code
-- Insert the revenue data into the table
SET @SQL = 'INSERT INTO dbo.' + @TableName + ' ' +
           ...
EXEC sp_executesql @SQL, N'@StartDate DATE, @EndDate DATE, @Period NVARCHAR(10), @CustomerID INT', @StartDate, @EndDate, @Period, @CustomerID;
Please try making these changes and run the stored procedure again. If you still encounter errors, please share the exact error message, and I will help you troubleshoot further.




User
CREATE OR ALTER PROCEDURE sp_CustomerRevenue
    @FromYear INT = NULL,
    @ToYear INT = NULL,
    @Period VARCHAR(10) = 'Y',
    @CustomerID INT = NULL
AS
BEGIN
    SET NOCOUNT ON;
    
    DECLARE @StartDate DATE, @EndDate DATE;
    DECLARE @TableName NVARCHAR(128), @SQL NVARCHAR(MAX);
    DECLARE @CustomerName NVARCHAR(50);
    
    -- Set the start and end dates based on the input parameters
SET @StartDate = ISNULL(CAST(@FromYear AS CHAR(4)) + '0101', (SELECT MIN(CONVERT(date, [Date])) FROM [Dimension].[Date]));
SET @EndDate = ISNULL(CAST(@ToYear AS CHAR(4)) + '1231', (SELECT MAX(CONVERT(date, [Date])) FROM [Dimension].[Date]));

    
    -- Get the customer name if a CustomerID is provided
    SET @CustomerName = (SELECT [Customer] FROM [Dimension].[Customer] WHERE [Customer Key] = @CustomerID);
    
    -- Create the table name based on the input parameters
    -- Create the table name based on the input parameters
    SET @TableName = 'Revenue_';
    IF @CustomerID IS NULL
        SET @TableName += 'All';
    ELSE
    BEGIN
        SET @CustomerName = REPLACE(REPLACE(REPLACE(REPLACE(@CustomerName, '(', ''), ')', ''), ',', ''), ' ', '');
        SET @TableName += CAST(@CustomerID AS NVARCHAR) + '_' + @CustomerName;
    END
    IF @FromYear = @ToYear
        SET @TableName += '_' + CAST(@FromYear AS NVARCHAR);
    ELSE
        SET @TableName += '_' + CAST(@FromYear AS NVARCHAR) + '_' + CAST(@ToYear AS NVARCHAR);
    SET @TableName += '_' + LEFT(@Period, 1);

    
    -- Drop the table if it already exists
    SET @SQL = 'IF OBJECT_ID(''dbo.' + @TableName + ''', ''U'') IS NOT NULL ' +
               'DROP TABLE dbo.' + @TableName;
    EXEC sp_executesql @SQL;
    
    -- Create the table
    SET @SQL = 'CREATE TABLE dbo.' + @TableName + ' ' +
               '([CustomerID] INT, ' +
               '[CustomerName] NVARCHAR(50), ' +
               '[Period] NVARCHAR(8), ' +
               '[Revenue] NUMERIC(19,2))';
    EXEC sp_executesql @SQL;
    
    -- Insert the revenue data into the table
    SET @SQL = 'INSERT INTO dbo.' + @TableName + ' ' +
               'SELECT ' +
               '    c.[Customer Key] AS [CustomerID], ' +
               '    c.[Customer] AS [CustomerName], ' +
               '    CASE ' +
               '        WHEN @Period IN (''Month'', ''M'') THEN FORMAT(d.[Date], ''MMM yyyy'') ' +
               '        WHEN @Period IN (''Quarter'', ''Q'') THEN ''Q'' + CAST(DATEPART(QUARTER, d.[Date]) AS NVARCHAR) + '' '' + CAST(DATEPART(YEAR, d.[Date]) AS NVARCHAR) ' +
               '        ELSE CAST(DATEPART(YEAR, d.[Date]) AS NVARCHAR) ' +
               '    END AS [Period], ' +
               '    ISNULL(SUM(s.[Quantity] * s.[Unit Price]), 0) AS [Revenue] ' +
               'FROM ' +
               '    [Dimension].[Customer] c ' +
               'LEFT JOIN ' +
               '    [Fact].[Sale] s ON c.[Customer Key] = s.[Customer Key] ' +
               'LEFT JOIN ' +
               '    [Dimension].[Date] d ON s.[Invoice Date Key] = d.[Date] ' +
               'WHERE ' +
               '    d.[Date] BETWEEN @StartDate AND @EndDate ' +
               '    AND (@CustomerID IS NULL OR c.[Customer Key] = @CustomerID) ' +
               'GROUP BY ' +
               '    c.[Customer Key], c.[Customer], d.[Date]';
    EXEC sp_executesql @SQL, N'@StartDate DATE, @EndDate DATE, @Period NVARCHAR(10), @CustomerID INT', @StartDate, @EndDate, @Period, @CustomerID;
    

	DECLARE @SQL_OUT NVARCHAR(MAX);
	SET @SQL_OUT=N'SELECT * FROM dbo.' + @TableName
	EXEC sp_executesql @SQL_OUT

    SET NOCOUNT OFF;

	
END


go


EXEC sp_CustomerRevenue  @ToYear = 2016, @Period = 'M', @CustomerID = 379;


Msg 241, Level 16, State 1, Procedure sp_CustomerRevenue, Line 15 [Batch Start Line 89]
Conversion failed when converting date and/or time from character string.

 if i select value from SELECT MIN(CONVERT(date, [Date])) FROM [Dimension].[Date] i got this 
2013-01-01
ChatGPT
The conversion error is occurring because the Dimension.Date table's Date column data type is not DATE. You can check the data type of this column by running the following query:

sql
Copy code
SELECT COLUMN_NAME, DATA_TYPE
FROM INFORMATION_SCHEMA.COLUMNS
WHERE TABLE_NAME = 'Date' AND TABLE_SCHEMA = 'Dimension';
Please confirm the data type of the Date column.

I see you've already modified the @StartDate and @EndDate calculation to convert the date explicitly. This change should work if the Date column has a valid date in string format.

You are also setting the @SQL variable multiple times, which means you are overwriting its value before executing it. The correct way to execute multiple dynamic SQL statements is to create one dynamic SQL statement and then execute it once at the end of the stored procedure. You should concatenate the strings for the drop table, create table, and insert operations into a single @SQL variable and then execute it only once.

Also, I noticed that you are not handling the case when @FromYear is NULL but @ToYear is not NULL in the @TableName variable construction. This will result in an incorrect table name, for example, 'Revenue_379_WingtipToysBellAcresPA__2016_M' instead of 'Revenue_379_WingtipToysBellAcresPA_2013_2016_M'. You need to handle this case in your code.

Here's the updated stored procedure:

sql
Copy code
CREATE OR ALTER PROCEDURE sp_CustomerRevenue
    @FromYear INT = NULL,
    @ToYear INT = NULL,
    @Period VARCHAR(10) = 'Y',
    @CustomerID INT = NULL
AS
BEGIN
    SET NOCOUNT ON;
    
    DECLARE @StartDate DATE, @EndDate DATE;
    DECLARE @TableName NVARCHAR(128), @SQL NVARCHAR(MAX);
    DECLARE @CustomerName NVARCHAR(50);
    
    -- Set the start and end dates based on the input parameters
    SET @StartDate = ISNULL(CAST(@FromYear AS CHAR(4)) + '0101', (SELECT MIN(CONVERT(DATE, [Date])) FROM [Dimension].[Date]));
    SET @EndDate = ISNULL(CAST(@ToYear AS CHAR(4)) + '1231', (SELECT MAX(CONVERT(DATE, [Date])) FROM [Dimension].[Date]));

    -- Get the customer name if a CustomerID is provided
    SET @CustomerName = (SELECT [Customer] FROM [Dimension].[Customer] WHERE [Customer Key] = @CustomerID);
    
    -- Create the table name based on the input parameters
    SET @TableName = 'Revenue_';
    IF @CustomerID IS NULL
        SET @TableName += 'All';
    ELSE
    BEGIN
        SET @CustomerName = REPLACE(REPLACE(REPLACE(REPLACE(@CustomerName, '(', ''), ')', ''), ',', ''), ' ', '');
        SET @TableName += CAST(@CustomerID AS NVARCHAR) + '_' + @CustomerName;
    END
    
    IF @FromYear IS NULL
        SET @TableName += '_' + CAST((SELECT MIN(YEAR(CONVERT(DATE, [Date]))) FROM [Dimension].[Date]) AS NVARCHAR) + '_' + CAST(@ToYear AS NVARCHAR);
    ELSE IF @ToYear IS NULL
        SET @TableName += '_' + CAST(@FromYear AS NVARCHAR) + '_' + CAST((SELECT MAX(YEAR(CONVERT(DATE, [Date]))) FROM [Dimension].[Date]) AS NVARCHAR);
    ELSE IF @FromYear = @ToYear
        SET @TableName += '_' + CAST(@FromYear AS NVARCHAR);
    ELSE
        SET @TableName += '_' + CAST(@FromYear AS NVARCHAR) + '_' +



User
confirm that data type of the Date column is date
ChatGPT
Great, the data type of the Date column is indeed DATE.

The error you're encountering seems to be because of the default values for @FromYear and @ToYear. Since you're setting the default values to NULL, the ISNULL function will then take the minimum and maximum dates from the Dimension.Date table. However, if there are any values in the Dimension.Date table that are not of the DATE type, this will cause a conversion error.

To avoid this issue, you can change the default values of @FromYear and @ToYear to the minimum and maximum years of your Dimension.Date table or another range that you're sure exists in your Dimension.Date table. Also, make sure that the Dimension.Date table's Date column has valid dates.

If you want to keep the current logic of using NULL as the default value, you should first ensure that all the values in the Dimension.Date table's Date column are valid dates, and there are no NULL or empty values. You can check this by running the following query:

sql
Copy code
SELECT [Date]
FROM [Dimension].[Date]
WHERE [Date] IS NULL OR TRY_CONVERT(DATE, [Date]) IS NULL;
This will return all the NULL or invalid date values in the Dimension.Date table's Date column. If this query returns any rows, you should correct these values before running your sp_CustomerRevenue stored procedure.

Let me know if you have more questions or need further assistance!




User
this query returns any rows
ChatGPT
The query returning rows indicates that there are NULL or invalid date values in your Dimension.Date table's Date column.

You will need to clean up your data by either removing those rows or updating them with valid date values. After you have cleaned up your data, you can try running the sp_CustomerRevenue stored procedure again.

You can clean up the data by running an UPDATE or DELETE statement. For example, if you want to delete all rows with NULL or invalid dates, you can run the following query:

sql
Copy code
DELETE FROM [Dimension].[Date]
WHERE [Date] IS NULL OR TRY_CONVERT(DATE, [Date]) IS NULL;
If you want to update the NULL or invalid dates to a specific date, you can run the following query:

sql
Copy code
UPDATE [Dimension].[Date]
SET [Date] = 'YYYY-MM-DD' -- replace with the desired date
WHERE [Date] IS NULL OR TRY_CONVERT(DATE, [Date]) IS NULL;
After cleaning up your data, make sure to re-run the query that checks for NULL or invalid dates to ensure that all the data is correct. Then you can try running the sp_CustomerRevenue stored procedure again.

Let me know if you need any more help!




User

(0 rows affected)

Completion time: 2023-08-30T17:55:51.5410450+03:00
ChatGPT
The fact that the query affected 0 rows suggests that there are no NULL or invalid date values in your Dimension.Date table's Date column.

Given that, the error you are encountering might be due to another issue. The error message indicates that there is a problem with converting a date and/or time from a character string. This could be due to the way the @StartDate and @EndDate variables are being set.

In your stored procedure, you are setting @StartDate and @EndDate as follows:

sql
Copy code
SET @StartDate = ISNULL(CAST(@FromYear AS CHAR(4)) + '0101', (SELECT MIN(CONVERT(date, [Date])) FROM [Dimension].[Date]));
SET @EndDate = ISNULL(CAST(@ToYear AS CHAR(4)) + '1231', (SELECT MAX(CONVERT(date, [Date])) FROM [Dimension].[Date]));
The above lines are attempting to construct a date from the @FromYear and @ToYear parameters, or, if those parameters are NULL, by selecting the minimum and maximum Date values from the Dimension.Date table.

However, the constructed dates are in the YYYYMMDD format, which is not a valid date format. You should change the format to YYYY-MM-DD.

Try modifying the @StartDate and @EndDate lines as follows:

sql
Copy code
SET @StartDate = ISNULL(CAST(@FromYear AS CHAR(4)) + '-01-01', (SELECT MIN(CONVERT(date, [Date])) FROM [Dimension].[Date]));
SET @EndDate = ISNULL(CAST(@ToYear AS CHAR(4)) + '-12-31', (SELECT MAX(CONVERT(date, [Date])) FROM [Dimension].[Date]));
Once you have made these changes, try running the sp_CustomerRevenue stored procedure again.




User
when i run procedure i got duplicate values in result table 
EXEC sp_CustomerRevenue @FromYear=2013, @ToYear = 2016, @Period = 'Y', @CustomerID = 379;

CustomerID	CustomerName	Period	Revenue
379	Wingtip Toys (Bell Acres, PA)	Jan 2013	3040.00
379	Wingtip Toys (Bell Acres, PA)	Jan 2013	1159.80
379	Wingtip Toys (Bell Acres, PA)	Feb 2013	9692.00
379	Wingtip Toys (Bell Acres, PA)	Feb 2013	2860.00
379	Wingtip Toys (Bell Acres, PA)	Mar 2013	3928.00
379	Wingtip Toys (Bell Acres, PA)	Mar 2013	4924.00
379	Wingtip Toys (Bell Acres, PA)	Mar 2013	2389.00
379	Wingtip Toys (Bell Acres, PA)	Apr 2013	12000.00
379	Wingtip Toys (Bell Acres, PA)	May 2013	3797.60
379	Wingtip Toys (Bell Acres, PA)	May 2013	594.00
379	Wingtip Toys (Bell Acres, PA)	Jun 2013	3068.00
379	Wingtip Toys (Bell Acres, PA)	Jun 2013	296.00
379	Wingtip Toys (Bell Acres, PA)	Jul 2013	641.00
379	Wingtip Toys (Bell Acres, PA)	Jul 2013	2455.50
ChatGPT
The duplicate values in your result set are caused by the GROUP BY clause in your INSERT statement:

sql
Copy code
GROUP BY 
    c.[Customer Key], c.[Customer], d.[Date]
This clause groups the result set by the Customer Key, Customer, and Date columns, which means you'll get one row per unique combination of these three values. If there are multiple sales for a customer on a single day, they will appear as separate rows in your result set, as you are seeing.

To fix this, you need to modify the GROUP BY clause to group by the Customer Key, Customer, and Period columns instead:

sql
Copy code
GROUP BY 
    c.[Customer Key], c.[Customer], 
    CASE 
        WHEN @Period IN ('Month', 'M') THEN FORMAT(d.[Date], 'MMM yyyy') 
        WHEN @Period IN ('Quarter', 'Q') THEN 'Q' + CAST(DATEPART(QUARTER, d.[Date]) AS NVARCHAR) + ' ' + CAST(DATEPART(YEAR, d.[Date]) AS NVARCHAR) 
        ELSE CAST(DATEPART(YEAR, d.[Date]) AS NVARCHAR) 
    END
Once you have made this change, try running the sp_CustomerRevenue stored procedure again. This should remove the duplicate values from your result set.




User
CREATE OR ALTER PROCEDURE sp_CustomerRevenue
    @FromYear INT = NULL,
    @ToYear INT = NULL,
    @Period VARCHAR(10) = 'Y',
    @CustomerID INT = NULL
AS
BEGIN
    SET NOCOUNT ON;
    
    DECLARE @StartDate DATE, @EndDate DATE;
    DECLARE @TableName NVARCHAR(128), @SQL NVARCHAR(MAX);
    DECLARE @CustomerName NVARCHAR(50);
    
    -- Set the start and end dates based on the input parameters
SET @StartDate = ISNULL(CAST(@FromYear AS CHAR(4)) + '-01-01', (SELECT MIN(CONVERT(date, [Date])) FROM [Dimension].[Date]));
SET @EndDate = ISNULL(CAST(@ToYear AS CHAR(4)) + '-12-31', (SELECT MAX(CONVERT(date, [Date])) FROM [Dimension].[Date]));


    
    -- Get the customer name if a CustomerID is provided
    SET @CustomerName = (SELECT [Customer] FROM [Dimension].[Customer] WHERE [Customer Key] = @CustomerID);
    
    -- Create the table name based on the input parameters
    -- Create the table name based on the input parameters
    SET @TableName = 'Revenue_';
    IF @CustomerID IS NULL
        SET @TableName += 'All';
    ELSE
    BEGIN
        SET @CustomerName = REPLACE(REPLACE(REPLACE(REPLACE(@CustomerName, '(', ''), ')', ''), ',', ''), ' ', '');
        SET @TableName += CAST(@CustomerID AS NVARCHAR) + '_' + @CustomerName;
    END
    IF @FromYear = @ToYear
        SET @TableName += '_' + CAST(@FromYear AS NVARCHAR);
    ELSE
        SET @TableName += '_' + CAST(@FromYear AS NVARCHAR) + '_' + CAST(@ToYear AS NVARCHAR);
    SET @TableName += '_' + LEFT(@Period, 1);

    
    -- Drop the table if it already exists
    SET @SQL = 'IF OBJECT_ID(''dbo.' + @TableName + ''', ''U'') IS NOT NULL ' +
               'DROP TABLE dbo.' + @TableName;
    EXEC sp_executesql @SQL;
    
    -- Create the table
    SET @SQL = 'CREATE TABLE dbo.' + @TableName + ' ' +
               '([CustomerID] INT, ' +
               '[CustomerName] NVARCHAR(50), ' +
               '[Period] NVARCHAR(8), ' +
               '[Revenue] NUMERIC(19,2))';
    EXEC sp_executesql @SQL;
    
    -- Insert the revenue data into the table
    SET @SQL = 'INSERT INTO dbo.' + @TableName + ' ' +
               'SELECT ' +
               '    c.[Customer Key] AS [CustomerID], ' +
               '    c.[Customer] AS [CustomerName], ' +
               '    CASE ' +
               '        WHEN @Period IN (''Month'', ''M'') THEN FORMAT(d.[Date], ''MMM yyyy'') ' +
               '        WHEN @Period IN (''Quarter'', ''Q'') THEN ''Q'' + CAST(DATEPART(QUARTER, d.[Date]) AS NVARCHAR) + '' '' + CAST(DATEPART(YEAR, d.[Date]) AS NVARCHAR) ' +
               '        ELSE CAST(DATEPART(YEAR, d.[Date]) AS NVARCHAR) ' +
               '    END AS [Period], ' +
               '    ISNULL(SUM(s.[Quantity] * s.[Unit Price]), 0) AS [Revenue] ' +
               'FROM ' +
               '    [Dimension].[Customer] c ' +
               'LEFT JOIN ' +
               '    [Fact].[Sale] s ON c.[Customer Key] = s.[Customer Key] ' +
               'LEFT JOIN ' +
               '    [Dimension].[Date] d ON s.[Invoice Date Key] = d.[Date] ' +
               'WHERE ' +
               '    d.[Date] BETWEEN @StartDate AND @EndDate ' +
               '    AND (@CustomerID IS NULL OR c.[Customer Key] = @CustomerID) ' +
               'GROUP BY ' +
               '    c.[Customer Key], c.[Customer], d.[Date]';
    EXEC sp_executesql @SQL, N'@StartDate DATE, @EndDate DATE, @Period NVARCHAR(10), @CustomerID INT', @StartDate, @EndDate, @Period, @CustomerID;
    

	DECLARE @SQL_OUT NVARCHAR(MAX);
	SET @SQL_OUT=N'SELECT * FROM dbo.' + @TableName
	EXEC sp_executesql @SQL_OUT

    SET NOCOUNT OFF;

	
END

which part of code i need to replace to get rid of duplicated values 
CustomerID	CustomerName	Period	Revenue
379	Wingtip Toys (Bell Acres, PA)	Jan 2013	3040.00
379	Wingtip Toys (Bell Acres, PA)	Jan 2013	1159.80
379	Wingtip Toys (Bell Acres, PA)	Feb 2013	9692.00
379	Wingtip Toys (Bell Acres, PA)	Feb 2013	2860.00
379	Wingtip Toys (Bell Acres, PA)	Mar 2013	3928.00
379	Wingtip Toys (Bell Acres, PA)	Mar 2013	4924.00
379	Wingtip Toys (Bell Acres, PA)	Mar 2013	2389.00
379	Wingtip Toys (Bell Acres, PA)	Apr 2013	12000.00
379	Wingtip Toys (Bell Acres, PA)	May 2013	3797.60
379	Wingtip Toys (Bell Acres, PA)	May 2013	594.00
379	Wingtip Toys (Bell Acres, PA)	Jun 2013	3068.00
379	Wingtip Toys (Bell Acres, PA)	Jun 2013	296.00
379	Wingtip Toys (Bell Acres, PA)	Jul 2013	641.00
379	Wingtip Toys (Bell Acres, PA)	Jul 2013	2455.50
ChatGPT
The duplication occurs because you are grouping by d.[Date] which is at the day level. To get rid of the duplicates, you need to replace the GROUP BY clause in the INSERT statement with the CASE statement that you are using to generate the Period column.

Replace:

sql
Copy code
'GROUP BY ' +
'    c.[Customer Key], c.[Customer], d.[Date]';
With:

sql
Copy code
'GROUP BY ' +
'    c.[Customer Key], c.[Customer], ' +
'    CASE ' +
'        WHEN @Period IN (''Month'', ''M'') THEN FORMAT(d.[Date], ''MMM yyyy'') ' +
'        WHEN @Period IN (''Quarter'', ''Q'') THEN ''Q'' + CAST(DATEPART(QUARTER, d.[Date]) AS NVARCHAR) + '' '' + CAST(DATEPART(YEAR, d.[Date]) AS NVARCHAR) ' +
'        ELSE CAST(DATEPART(YEAR, d.[Date]) AS NVARCHAR) ' +
'    END';
After making this change, the INSERT statement will group the data by the Period column, which should remove the duplicate values from your result set.
